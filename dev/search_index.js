var documenterSearchIndex = {"docs":
[{"location":"input/#Input-options","page":"Input options","title":"Input options","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"DocTestSetup = quote\n    options = Dict()\n    Nc = 2\nend","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#Grid","page":"Input options","title":"Grid","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#dx,-dy,-dz","page":"Input options","title":"dx, dy, dz","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Cell size along x, y, z dimension","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nFloat64 -\nVector{Float64} N_c","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Examples:","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"dx\"] = 50.;\n\njulia> options[\"dy\"] = 50.;\n\njulia> options[\"dz\"] = 10.;\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"dx\"] = 50. * ones(Nc);\n\njulia> options[\"dy\"] = 50. * ones(Nc);\n\njulia> options[\"dz\"] = 10. * ones(Nc);\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#d","page":"Input options","title":"d","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Cell center depths","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nFloat64 -\nVector{Float64} N_c","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Example:","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"d\"] = 8000.;\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"d\"] = 8000. * ones(Nc);\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#nx,-ny,-nz","page":"Input options","title":"nx, ny, nz","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Number of cells along x, y, z dimension","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nInt64 -","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Example:","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"nx\"] = 50;\n\njulia> options[\"ny\"] = 60;\n\njulia> options[\"nz\"] = 1;\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#Rock","page":"Input options","title":"Rock","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#perm","page":"Input options","title":"perm","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Cell permeability value","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nFloat64 -\nVector{Float64} N_c\nString -","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Example:","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"perm\"] = 200.;\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"perm\"] = 200. * ones(Nc);\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"perm\"] = \"PERM.DAT\";\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Example input file format","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"\nPERM\n-- lines starting with \"--\" are comments\n-- empty lines before keyword are allowed\n-- empty lines after / are allowed\n-- each line can have different width\n-- allowed delimiters: single/multiple spaces, tabs and combination of spaces and tabs\n\n\n-- Permeability values (md)\n-- Simple system 10x1\n-- \"n*v\" represents repeated values : \"n\" repeated value of \"v\"\n\n462.7965311791255 2*549.4547649098886\n\n-- comments between lines are allowed\n\n575.4880710664381 469.0640845765829 624.687484573518\n741.1518277078972       457.5232943356377\n608.3175306515967           \n429.1722270419058\n\n/\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#poro","page":"Input options","title":"poro","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Cell porosity value","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nFloat64 -\nVector{Float64} N_c","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Example:","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"poro\"] = 0.2;\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"poro\"] = 0.2 * ones(Nc);\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#Fluid","page":"Input options","title":"Fluid","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#fluid","page":"Input options","title":"fluid","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Fluid system type.","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nString -","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Supported values\n\"OW\" - oil-water system\nExamples","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"fluid\"] = \"OW\";\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#po","page":"Input options","title":"po","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Initial oil phase pressure","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nFloat64 -\nVector{Float64} N_c","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Examples","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"po\"] = 6000.0;\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"po\"] = 6000.0 * ones(Nc);\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#sw","page":"Input options","title":"sw","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Initial water phase saturation","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nFloat64 -\nVector{Float64} N_c","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Examples","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"sw\"] = 0.1;\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"sw\"] = 0.1 * ones(Nc);\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#PVDO","page":"Input options","title":"PVDO","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Input file for dead oil PVT table","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nString -","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"PVDO\"] = \"PVDO.DAT\";\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Example file format:","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"\nPVDO\n\n-- lines starting with \"--\" are comments\n-- empty lines before keyword are allowed\n-- empty lines after / are allowed\n-- empty lines between rows are allowed\n-- allowed delimiters: single/multiple spaces, tabs and combination of spaces and tabs\n-- pref(psi) bo  vis_o(cp)\n\n2465.646 0.9884 1.1663\n-- comments between rows are allowed\n\n3335.874 0.9766    1.1695\n4138.369254 0.9658 1.1724\n4819.467702 0.9565 1.1749    \n5801.374962 0.9432 1.1784\n6788.358552 0.9299 1.182         \n7082.20554 0.9259 1.1831\n\n/\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#PVTW","page":"Input options","title":"PVTW","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Input file for the water PVT function","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nString -","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"PVTW\"] = \"PVTW.DAT\";\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Example file format","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"\nPVTW\n\n-- lines starting with \"--\" are comments\n-- empty lines before keyword are allowed\n-- empty lines after / are allowed\n-- empty lines between rows are allowed\n-- allowed delimiters: single/multiple spaces, tabs and combination of spaces and tabs\n-- see keyword PVTW in Eclipse reference manual\n\n-- pref(psi) bw  cw (1/psi) vis_w(cp) c_visw(1/psi)\n3962.194496   1.029     3.17E-06 0.31 0\n/\n\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#SWOF","page":"Input options","title":"SWOF","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Input file for the oil-water two-phase relative permeabilty table","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nString -","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"SWOF\"] = \"SWOF.DAT\";\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Example file format:","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"\nSWOF\n\n-- lines starting with \"--\" are comments\n-- empty lines before keyword are allowed\n-- empty lines after / are allowed\n-- empty lines between rows are allowed\n-- allowed delimiters: single/multiple spaces, tabs and combination of spaces and tabs\n\n-- sw krw kro pcw(psi)\n0.0000 0 0.9000 0\n0.1000 0 0.9000 0\n0.2000 0.0102 0.6612 0\n0.3000 0.0408 0.4592 0\n0.4000 0.0918 0.2939 0\n0.5000 0.1633 0.1653 0\n0.6000 0.2551 0.0735 0\n0.7000 0.3673 0.0184 0\n0.8000 0.5000 0.0000 0\n1.0000 0.5000 0.0000 0.0000\n/\n\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#Wells","page":"Input options","title":"Wells","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#producers,-injectors","page":"Input options","title":"producers, injectors","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"List of producers/injectors","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nVector{Dict} number of producers/injectors","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Each dictionary contains the key-value pairs\n\"name\" -> String - well name\n\"perforation\" -> Vector{Tuple{Int, Int, Int}} - indices for perforated grid blocks\n\"radius\" -> Float64 - wellbore radius\n\"mode\" -> String - well control mode\n\"bhp\": constant BHP\n\"shut\": shut-in\n\"orat\": constant oil rate\n\"wrat\": constant water rate\n\"lrat\": constatnt liquid rate\n\"target\" -> Float64 - well control target\nExample","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"producers\"] = [];\n\njulia> p1 = Dict();\n\njulia> p1[\"name\"] = \"P1\"; p1[\"perforation\"] = [(1,1,1)]; p1[\"radius\"] = 0.5;\n\njulia> p1[\"mode\"] = \"bhp\"; p1[\"target\"] = 5500.;\n\njulia> push!(options[\"producers\"], p1);\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"injectors\"] = [];\n\njulia> i1 = Dict();\n\njulia> i1[\"name\"] = \"I1\"; i1[\"perforation\"] = [(30,15,1)]; i1[\"radius\"] = 0.5;\n\njulia> i1[\"mode\"] = \"bhp\"; i1[\"target\"] = 6500.;\n\njulia> push!(options[\"injectors\"], i1);\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#Schedule","page":"Input options","title":"Schedule","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#dt0","page":"Input options","title":"dt0","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Initial time step size","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nFloat64 -","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Example","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"dt0\"] = 0.1;\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#dt_max","page":"Input options","title":"dt_max","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Maximum time step size","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nFloat64 -","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Example","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"dt_max\"] = 50.0;\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#t_end","page":"Input options","title":"t_end","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Maximum time step size","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nFloat64 -","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Example","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"t_end\"] = 1825.0;\n","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#Nonlinear-solver","page":"Input options","title":"Nonlinear solver","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#min_err","page":"Input options","title":"min_err","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Minimum residual error for convergence","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nFloat64 -","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Example","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"min_err\"] = 1.0e-3;\n","category":"page"},{"location":"input/#Linear-solver","page":"Input options","title":"Linear solver","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"","category":"page"},{"location":"input/#linear_solver_backend","page":"Input options","title":"linear_solver_backend","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nString -","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Supported values\n\"DUNEISTL\" (default) - linear solvers from the ISTL module from DUNE\n\"JULIA\" - linear solvers from IterativeSolvers.jl\nExample","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"linear_solver_backend\"] = \"DUNEISTL\";\n\njulia> options[\"linear_solver_backend\"] = \"JULIA\";\n","category":"page"},{"location":"input/#linear_solver_type","page":"Input options","title":"linear_solver_type","text":"","category":"section"},{"location":"input/","page":"Input options","title":"Input options","text":"Data type","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Type Size\nString -","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"Supported values\nwhen options[\"linear_solver_backend\"]=\"DUNEISTL\"\n\"GMRES_ILU\" - GMRes solver with incomplete LU preconditioner\n\"BICGSTAB_ILU\" - BiCGstab solver with incomplete LU preconditioner\nwhen options[\"linear_solver_backend\"]=\"JULIA\"\n\"GMRES_ILU\" - GMRes solver with incomplete LU preconditioner\n\"GMRES_CPR\" - GMRes solver with CPR preconditioner\n\"BICGSTAB_ILU\" - BiCGstab solver with incomplete LU preconditioner\n\"BICGSTAB_CPR\" - BiCGstab solver with CPR preconditioner\n\"JULIA_BACKSLASH\" - Julia backslash solver\nRecommendation for choosing solvers\nOverall best solver is \"BICGSTAB_ILU\" with \"DUNEISTL\" backend\nIf \"BICGSTAB_ILU\" with \"DUNEISTL\" backend failed\nChoose \"GMRES_ILU\" or \"BICGSTAB_ILU\" with \"JULIA\" backend for small problems\nChoose \"GMRES_CPR\" or \"BICGSTAB_CPR\" with \"JULIA\" backend for large problems\nOnly use \"JULIA_BACKSLASH\" for very small problems or problems where robustness is the top priority and other solvers can't converge\nExample","category":"page"},{"location":"input/","page":"Input options","title":"Input options","text":"julia> options[\"linear_solver_type\"] = \"BICGSTAB_ILU\";\n","category":"page"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.get_model","category":"page"},{"location":"api/#ResSimAD.Models.get_model","page":"API functions","title":"ResSimAD.Models.get_model","text":"get_model(example_name::String)\n\nGet example model example_name.\n\nExamples\n\njulia> using ResSimAD: get_model\n\njulia> sim, options = get_model(\"example1\");\n\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.runsim","category":"page"},{"location":"api/#ResSimAD.SimMaster.runsim","page":"API functions","title":"ResSimAD.SimMaster.runsim","text":"runsim(sim::Sim)\n\nRun simulation from day sim.scheduler.t_current to day sim.scheduler.time_step[end]\n\nExamples\n\njulia> using ResSimAD: get_model, runsim\n\njulia> sim, options = get_model(\"example1\");\n\njulia> sim.scheduler.t_current\n0.0\n\njulia> sim.scheduler.time_step[end]\n1825.0\n\njulia> runsim(sim);\n\njulia> sim.scheduler.t_current\n1825.0\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.step_to","category":"page"},{"location":"api/#ResSimAD.SimMaster.step_to","page":"API functions","title":"ResSimAD.SimMaster.step_to","text":"step_to(sim::Sim, t::Float64)\n\nSimluate until day t.\n\nExamples\n\njulia> using ResSimAD: get_model, step_to\n\njulia> sim, options = get_model(\"example1\");\n\njulia> sim.scheduler.t_current\n0.0\n\njulia> step_to(sim, 100.0);\n\njulia> sim.scheduler.t_current\n100.0\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.time_step","category":"page"},{"location":"api/#ResSimAD.SimMaster.time_step","page":"API functions","title":"ResSimAD.SimMaster.time_step","text":"time_step(sim::Sim)\n\nSimluate for one time step. Time step length is sim.scheduler.dt.\n\nExamples\n\njulia> using ResSimAD: get_model, time_step\n\njulia> sim, options = get_model(\"example1\");\n\njulia> sim.scheduler.t_current\n0.0\n\njulia> sim.scheduler.dt\n0.1\n\njulia> time_step(sim);\n\njulia> sim.scheduler.t_current\n0.1\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.newton_step","category":"page"},{"location":"api/#ResSimAD.SimMaster.newton_step","page":"API functions","title":"ResSimAD.SimMaster.newton_step","text":"newton_step(sim::Sim)\n\nSimulate for one newton step.\n\nExamples\n\njulia> using ResSimAD: get_model, newton_step, get_residual_error\n\njulia> using Printf: @printf\n\njulia> sim, options = get_model(\"example1\");\n\njulia> @printf(\"%.3e\",get_residual_error(sim))\n2.210e-01\njulia> newton_step(sim)\n\njulia> @printf(\"%.3e\",get_residual_error(sim))\n1.927e-02\njulia> newton_step(sim)\n\njulia> @printf(\"%.3e\",get_residual_error(sim))\n9.871e-05\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.change_well_mode","category":"page"},{"location":"api/#ResSimAD.SimMaster.change_well_mode","page":"API functions","title":"ResSimAD.SimMaster.change_well_mode","text":"change_well_mode(sim::Sim, name::String, mode::String, target::Float64)\n\nChange the control mode of well name to be mode with target value target\n\nArguments\n\nsim::Sim: Sim object\nname::String: name of the well\nmode::String: target mode, not case sensitive\nproducers:\n\"bhp\": constant BHP\n\"shut\": shut-in\n\"orat\": constant oil rate\n\"wrat\": constant water rate\n\"lrat\": constatnt liquid rate\ninjectors:\n\"bhp\": constant BHP\n\"wrat\": constant water rate\ntarget::Float64\n\nExamples\n\njulia> using ResSimAD: get_model, change_well_mode, silence\n\njulia> silence();\n\njulia> sim, options = get_model(\"example1\");\n\njulia> change_well_mode(sim, \"P1\", \"bhp\", 6200.);\n\njulia> println(sim.facility[\"P1\"].mode)\nCBHP\n\njulia> println(sim.facility[\"P1\"].target)\n6200.0\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.change_well_target","category":"page"},{"location":"api/#ResSimAD.SimMaster.change_well_target","page":"API functions","title":"ResSimAD.SimMaster.change_well_target","text":"change_well_target(sim::Sim, name::String, target::Float64)\n\nChange the control target of well name to be target.\n\nArguments\n\nsim::Sim: Sim object\nname::String: name of the well\ntarget::Float64: well control target\n\nExamples\n\njulia> using ResSimAD: get_model, change_well_target, silence\n\njulia> silence();\n\njulia> sim, options = get_model(\"example1\");\n\njulia> change_well_target(sim, \"P1\", 6200.);\n\njulia> println(sim.facility[\"P1\"].target)\n6200.0\n\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.get_well_rates","category":"page"},{"location":"api/#ResSimAD.SimMaster.get_well_rates","page":"API functions","title":"ResSimAD.SimMaster.get_well_rates","text":"get_well_rates(sim::Sim, name::String, data::String)\n\nGet column data from dataframe sim.facility[name].results\n\nArguments\n\nsim::Sim: Sim object\nname::String: name of the well\ndata::String: column name (case insensitive)\n\"TIME\": Time steps\n\"ORAT\": Oil rate\n\"WRAT\": Water rate\n\"GRAT\": Gas rate\n\"LRAT\": Liquid rate\n\"WBHP\": BHP\n\nExamples\n\njulia> using ResSimAD: get_model, runsim, get_well_rates, silence\n\njulia> silence();\n\njulia> sim, options = get_model(\"example1\");\n\njulia> runsim(sim);\n\njulia> tstep = get_well_rates(sim, \"P1\", \"Time\");\n\njulia> qo = get_well_rates(sim, \"P1\", \"ORAT\");\n\njulia> length(tstep) > 0\ntrue\njulia> length(qo) > 0\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.get_data","category":"page"},{"location":"api/#ResSimAD.SimMaster.get_data","page":"API functions","title":"ResSimAD.SimMaster.get_data","text":"get_data(sim::Sim, dataname::String)\n\nGet data for dataname dataname.\n\nExamples\n\njulia> using ResSimAD: get_model, step_to, get_data, silence\n\njulia> silence();\n\njulia> sim, options = get_model(\"example1\");\n\njulia> step_to(sim, 10.0);\n\njulia> λo = get_data(sim, \"λo\");\n\njulia> size(λo)\n(450,)\n\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.get_velocity","category":"page"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.get_state_map","category":"page"},{"location":"api/#ResSimAD.SimMaster.get_state_map","page":"API functions","title":"ResSimAD.SimMaster.get_state_map","text":"get_state_map(sim::Sim, var::String, t::Float64)\n\nGet state map for variable var at time t.\n\nExamples\n\njulia> using ResSimAD: get_model, runsim, get_state_map, get_well_rates, silence\n\njulia> silence();\n\njulia> sim, options = get_model(\"example1\");\n\njulia> runsim(sim);\n\njulia> t = get_well_rates(sim, \"P1\", \"TIME\");\n\njulia> po = get_state_map(sim, \"po\", t[end]);\n\njulia> size(po)\n(450,)\n\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.add_well","category":"page"},{"location":"api/#ResSimAD.SimMaster.add_well","page":"API functions","title":"ResSimAD.SimMaster.add_well","text":"add_well(sim::Sim, welltype::String, well_option::Dict)\n\nAdd one well of type welltype, with well setups specified in well_option\n\nArguments\n\nsim::Sim: Sim object\nwelltype::String: type of the well (case insensitive)\n\"injector\": injector\n\"producer\": producer\nwell_option::Dict: well setups with keys\n\"name\" -> String, name of the well\n\"perforation\" -> Vector{Tuple{Int, Int, Int}}, indices for perforated blocks\n\"radius\" -> Float64, well radius\n\"mode\" -> String, well control mode\n\"target\" -> Float64, well constrol target\n\nExamples\n\njulia> using ResSimAD: get_model, add_well, silence\n\njulia> silence();\n\njulia> sim, options = get_model(\"example1\");\n\njulia> length(keys(sim.facility))\n2\n\njulia> p2 = Dict(\"name\" => \"P2\", \"perforation\"=>[(5,5,1)], \"radius\"=>0.5, \"mode\"=>\"bhp\", \"target\"=>5600.);\n\njulia> add_well(sim, \"producer\", p2);\n\njulia> length(keys(sim.facility))\n3\n\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.shut_well","category":"page"},{"location":"api/#ResSimAD.SimMaster.shut_well","page":"API functions","title":"ResSimAD.SimMaster.shut_well","text":"shut_well(sim::Sim, name::String)\n\nShut well name\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.change_dt","category":"page"},{"location":"api/#ResSimAD.SimMaster.change_dt","page":"API functions","title":"ResSimAD.SimMaster.change_dt","text":"change_dt(sim::Sim, dt::Float64)\n\nSet next time step size to be dt\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.silence","category":"page"},{"location":"api/#ResSimAD.silence","page":"API functions","title":"ResSimAD.silence","text":"silence()\n\nDo not show any message except for \"error\" messages. See ResSimAD.verbose() for more information.\n\nExamples\n\njulia> using ResSimAD:silence\n\njulia> silence();\n\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.debug","category":"page"},{"location":"api/#ResSimAD.debug","page":"API functions","title":"ResSimAD.debug","text":"debug()\n\nShow \"debug\" messages. See ResSimAD.verbose() for more information.\n\nExamples\n\njulia> using ResSimAD:debug\n\njulia> debug();\n\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API functions","title":"API functions","text":"ResSimAD.verbose","category":"page"},{"location":"api/#ResSimAD.verbose","page":"API functions","title":"ResSimAD.verbose","text":"verbose(level::String)\n\nSet verbose level. Show messages with higher level than the set level. See Memento.jl for more information.\n\nArguments\n\nlevel::String: verbose levels (low to high)\n\"debug\": verbose message used for debugging\n\"info\": general information\n\"notice\": important events that are part of normal execution\n\"warn\": warning that may cause the program to fail\n\"error\": error that causes the program to terminate\n\nExamples\n\njulia> using ResSimAD:verbose\n\njulia> verbose(\"debug\");\n\n\n\n\n\n\n","category":"function"},{"location":"examples/#Example-models","page":"Example models","title":"Example models","text":"","category":"section"},{"location":"examples/","page":"Example models","title":"Example models","text":"There are several example models in the src/models/ folder. We can use the ResSimAD.get_model function to create these example models.","category":"page"},{"location":"examples/","page":"Example models","title":"Example models","text":"For instance, to create the example1 model:","category":"page"},{"location":"examples/","page":"Example models","title":"Example models","text":"using ResSimAD:get_model, runsim\nsim, options = get_model(\"example1\");\nrunsim(sim);","category":"page"},{"location":"examples/","page":"Example models","title":"Example models","text":"Example code for simulating the example models and plotting results are available in the examples/ folder.","category":"page"},{"location":"examples/#List-of-example-models","page":"Example models","title":"List of example models","text":"","category":"section"},{"location":"examples/","page":"Example models","title":"Example models","text":"ResSimAD.Models.example1","category":"page"},{"location":"examples/#ResSimAD.Models.example1","page":"Example models","title":"ResSimAD.Models.example1","text":"example1()\n\nExample model 1.\n\nModel description\n\nDimension: 30times15times1\nGrid size: 500times500times200 (ft)\nPermeability: 200.0 md\nPorosity: 0.2\nFluid: Oil-Water\nInitial pressure: 6000.0 psi\nInitial water saturation: 0.1\nWells:\nP1: producer at (1, 1, 1), constant BHP 5500.0 psi\nI1: injector at (30, 15, 1), constant BHP 6500.0 psi\nSchedule:\ndt0: 0.1 Day\ndt_max: 30.0 Day\nt_end: 1825 Day\n\n\n\n\n\n","category":"function"},{"location":"examples/","page":"Example models","title":"Example models","text":"ResSimAD.Models.example2","category":"page"},{"location":"examples/#ResSimAD.Models.example2","page":"Example models","title":"ResSimAD.Models.example2","text":"example2()\n\nExample model 2.\n\nModel description\n\nDimension: 60times60times1\nGrid size: 2000times2000times600 (ft)\nPermeability: bimodal channel system\nPorosity: 0.2\nFluid: Oil-Water\nInitial pressure: 6000.0 psi\nInitial water saturation: 0.1\nWells:\nP1: producer at (20, 18, 1), constant BHP 5900.0 psi\nP2: producer at (13, 35, 1), constant BHP 5900.0 psi\nI1: injector at (40, 40, 1), constant BHP 6100.0 psi\nI2: injector at (25, 53, 1), constant BHP 6100.0 psi\nSchedule:\ndt0: 2.0 Day\ndt_max: 50.0 Day\nt_end: 1825.0 Day\n\n\n\n\n\n","category":"function"},{"location":"examples/","page":"Example models","title":"Example models","text":"ResSimAD.Models.example3","category":"page"},{"location":"examples/#ResSimAD.Models.example3","page":"Example models","title":"ResSimAD.Models.example3","text":"example3()\n\nExample model 3.\n\nModel description\n\nDimension: 60times60times1\nGrid size: 500times500times200 (ft)\nPermeability: Gaussian variogram model\nPorosity: 0.2\nFluid: Oil-Water\nInitial pressure: 6000.0 psi\nInitial water saturation: 0.1\nWells:\nP1: producer at (9, 53, 1), constant BHP 5900.0 psi\nP2: producer at (51, 11, 1), constant oil rate 500.0 STB/Day\nP3: producer at (51, 51, 1), constant liquid rate 800.0 STB/Day\nI1: injector at (8, 24, 1), constant BHP 6100.0 psi\nI2: injector at (36, 11, 1), constant water rate 800.0 STB/Day\nSchedule:\ndt0: 0.1 Day\ndt_max: 50.0 Day\nt_end: 1825.0 Day\n\n\n\n\n\n","category":"function"},{"location":"examples/","page":"Example models","title":"Example models","text":"ResSimAD.Models.example4","category":"page"},{"location":"examples/#ResSimAD.Models.example4","page":"Example models","title":"ResSimAD.Models.example4","text":"example4()\n\nExample model 4.\n\nModel description\n\nDimension: 60times60times40\nGrid size: 500times500times200 (ft)\nPermeability:\nkx: 2000.0 md\nky: 2000.0 md\nkz: 500.0 md\nPorosity: 0.2\nFluid: Oil-Water\nInitial pressure: 6000.0 psi at top layer\nInitial water saturation: 0.1\nWells:\nP1: producer at (9, 53, 1), constant BHP 5900.0 psi\nP2: producer at (51, 11, 1), constant oil rate 500.0 STB/Day\nI1: injector at (8, 24, 1), constant BHP 6100.0 psi\nI2: injector at (36, 11, 1), constant water rate 800.0 STB/Day\nSchedule:\ndt0: 0.01 Day\ndt_max: 30.0 Day\nt_end: 1825.0 Day\n\n\n\n\n\n","category":"function"},{"location":"workflow/#Basic-workflow","page":"Basic workflow","title":"Basic workflow","text":"","category":"section"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"The basic workflow for ResSimAD.jl consists of three steps:","category":"page"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"Specify simulation setups\nRun simulation\nVisualize simulation results","category":"page"},{"location":"workflow/#Specify-simulation-setups","page":"Basic workflow","title":"Specify simulation setups","text":"","category":"section"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"The most convenient way for specifying simulation setups for ResSimAD.jl is using a nested Dictionary. The following example shows how simulation setups are specified in the ResSimAD.Models.example1 model.","category":"page"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"using ResSimAD: get_example_data\n\n## Specify input\n# Grid and Rock\noptions = Dict();\noptions[\"nx\"] = 30; options[\"ny\"] = 15; options[\"nz\"] = 1;\noptions[\"dx\"] = 50.; options[\"dy\"] = 50.; options[\"dz\"] = 20.;\noptions[\"d\"] = 8000.;\noptions[\"perm\"] = 200.; options[\"poro\"] = 0.2;\n# Fluid\noptions[\"fluid\"] = \"OW\"\noptions[\"po\"] = 6000.;\noptions[\"sw\"] = 0.1;\noptions[\"PVDO\"] = get_example_data(\"PVDO.DAT\");\noptions[\"PVTW\"] = get_example_data(\"PVTW.DAT\");\noptions[\"SWOF\"] = get_example_data(\"SWOF.DAT\");\n# Wells\noptions[\"producers\"] = [];\np1 = Dict();\np1[\"name\"] = \"P1\"; p1[\"perforation\"] = [(1,1,1)]; p1[\"radius\"] = 0.5;\np1[\"mode\"] = \"bhp\"; p1[\"target\"] = 5500.;\npush!(options[\"producers\"], p1);\n\noptions[\"injectors\"] = [];\ni1 = Dict();\ni1[\"name\"] = \"I1\"; i1[\"perforation\"] = [(30,15,1)]; i1[\"radius\"] = 0.5;\ni1[\"mode\"] = \"bhp\"; i1[\"target\"] = 6500.;\npush!(options[\"injectors\"], i1);\n# Schedule\noptions[\"dt0\"] = 0.1\noptions[\"dt_max\"] = 50.; options[\"t_end\"] = 10 * 182.5;\noptions[\"min_err\"] = 1.0e-3;\n","category":"page"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"Currently supported input options are summarized in Input options.","category":"page"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"A Sim object can then be created with options:","category":"page"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"using ResSimAD: Sim\n\nsim = Sim(options)","category":"page"},{"location":"workflow/#Run-simluation","page":"Basic workflow","title":"Run simluation","text":"","category":"section"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"To run simulation, simply call:","category":"page"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"using ResSimAD: runsim\n\nrunsim(sim)","category":"page"},{"location":"workflow/#Visualize-and-save-simulation-results","page":"Basic workflow","title":"Visualize and save simulation results","text":"","category":"section"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"We use the Plots package for results visualizations.","category":"page"},{"location":"workflow/#Plot-production-rates","page":"Basic workflow","title":"Plot production rates","text":"","category":"section"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"Production rates for each well are stored in a DataFrame at sim.facility[name].results, where name is the name of the well. We can also use the ResSimAD.get_well_rates API function to extract production rates.","category":"page"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"using Plots\nusing Plots.PlotMeasures\nusing ResSimAD: get_well_rates\n\ngr(format=:svg) # hide\nENV[\"GKSwstype\"] = \"100\" #hide\n\n# Get time, P1 oil rate, I1 water injection rate\n# Option 1\nt = sim.facility[\"P1\"].results[!, \"TIME\"];\nqo = sim.facility[\"P1\"].results[!, \"ORAT\"];\nqw = sim.facility[\"I1\"].results[!, \"WRAT\"];\n# Note that column name is case sensitive (all letters must be upper case)\n\n# Option 2\nt = get_well_rates(sim, \"P1\", \"TIME\");\nqo = get_well_rates(sim, \"P1\", \"orat\");\nqw = get_well_rates(sim, \"I1\", \"Wrat\");\n# Column name will be converted to upper case inside get_well_rates\n# We recommend using Option 2\n\np1 = plot(t, qo, color=:black, marker=true,\n     xlabel=\"Day\", ylabel=\"Oil rate (STB/Day)\",\n     title=\"P1 oil rate\");\np2 = plot(t, -qw, color=:black, marker=true,\n     xlabel=\"Day\", ylabel=\"Water inj. Rate (STB/Day)\",\n     title=\"I1 water injection Rate\");\nplot(p1, p2, layout=(1,2), legend=false, size=(720,280), bottom_margin = 10px)","category":"page"},{"location":"workflow/#Plot-state-maps","page":"Basic workflow","title":"Plot state maps","text":"","category":"section"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"Snapshots of the primary variables (po and sw for this oil-water system) at each time step are stored in sim.reservoir.fluid.phases.o.p_rec and sim.reservoir.fluid.phases.w.s_rec. We can also use derived properties sim.po_rec and sim.sw_rec or the API function ResSimAD.get_state_map to access them.","category":"page"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"The type for sim.po_rec and sim.sw_rec is Dict{Float64, Vector{Float64}}, the keys are time step values (Float64 rounded to 6 digits).","category":"page"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"# Visualize state maps\nusing ResSimAD: get_grid_index, isproducer, get_state_map\n# Get po, sw at the end of simulation\n# Option 1\npo = sim.reservoir.fluid.phases.o.p_rec[round(t[end], digits=6)];\nsw = sim.reservoir.fluid.phases.w.s_rec[round(t[end], digits=6)];\n# Option 2\npo = sim.po_rec[round(t[end], digits=6)];\nsw = sim.sw_rec[round(t[end], digits=6)];\n# Option 3\npo = get_state_map(sim, \"po\", t[end]);\nsw = get_state_map(sim, \"sw\", t[end]);\n# `t` will be rounded to 6 digits inside get_state_map\n# We recommend using Option 3\n\n# Define a function for plotting wells\nfunction plot_wells_2d(plt, sim; markersize=5, color=:white)\n    for w in values(sim.facility)\n        i, j, _ = get_grid_index(sim.reservoir.grid, w.ind[1])\n        if isproducer(w)\n            marker = :circle\n        else\n            marker = :dtriangle\n        end\n        scatter!(plt, [j,], [i,], m=(marker, markersize, color), legend=false)\n    end\nend\n\n# Plot state maps\ncmap = cgrad(:jet);\np1 = heatmap(reshape(po, sim.nx, sim.ny), color=cmap, title=\"Po at Day $(t[end])\");\nplot_wells_2d(p1, sim);\np2 = heatmap(reshape(sw, sim.nx, sim.ny), color=cmap, title=\"Sw at Day $(t[end])\");\nplot_wells_2d(p2, sim);\nplot(p1, p2, layout=(1,2), size=(700,450))","category":"page"},{"location":"workflow/#Plot-newton-iterations","page":"Basic workflow","title":"Plot newton iterations","text":"","category":"section"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"Number of newton iterations at each time step is stored in sim.nsolver.num_iter, we can plot this to check the convergence behavior for this simulation run.","category":"page"},{"location":"workflow/","page":"Basic workflow","title":"Basic workflow","text":"newton_iter = sim.nsolver.num_iter;\nscatter(newton_iter, markershape=:square, size=(360,280), legend=false,\n        xlabel=\"Time step\", ylabel=\"Newton iterations\")","category":"page"},{"location":"precompile/#Precompile","page":"Precompile","title":"Precompile","text":"","category":"section"},{"location":"precompile/#Why-precompiling","page":"Precompile","title":"Why precompiling","text":"","category":"section"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"Quote from the PackageCompiler.jl documentation:","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"Julia is, in general, a \"just-barely-ahead-of-time\" compiled language. When you call a function for the first time, Julia compiles it for precisely the types of the arguments given. This can take some time. All subsequent calls within that same session use this fast compiled function, but if you restart Julia you lose all the compiled work.","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"In a new Julia session, it may feel slow when importing ResSimAD, creating Sim object, running simulation for the first time. This is because there are a lot of functions getting compiled \"just-barely-ahead-of-time\". These include functions in the ResSimAD.jl package itself and many methods in the dependencies of ResSimAD.jl.","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"The following code demonstrates this:","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"println(\"Importing ResSimAD (1st time) takes:\")\n@time using ResSimAD\n\nprintln(\"Creating Sim object (1st time) takes:\")\n@time sim, options = get_model(\"example1\")\n\nprintln(\"Running simulation (1st time) takes:\")\n\n@time runsim(sim);\n\n\nprintln(\"\\nImporting ResSimAD (2nd time) takes:\")\n@time using ResSimAD\n\nprintln(\"Creating Sim object (2nd time) takes:\")\n@time sim, options = get_model(\"example1\")\n\nprintln(\"Running simulation (2nd time) takes:\")\n\n@time runsim(sim);\n","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"There are huge differences in the execution time between the first calls and the second calls:","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"Importing ResSimAD (1st time) takes:\n  2.962693 seconds (6.16 M allocations: 384.068 MiB)\nCreating Sim object (1st time) takes:\n 28.540179 seconds (59.03 M allocations: 2.926 GiB, 5.07% gc time)\nRunning simulation (1st time) takes:\n  1.797259 seconds (4.20 M allocations: 364.556 MiB, 5.76% gc time)\n\nImporting ResSimAD (2nd time) takes:\n  1.004753 seconds (2.59 M allocations: 122.898 MiB, 1.96% gc time)\nCreating Sim object (2nd time) takes:\n  0.001944 seconds (2.95 k allocations: 1.226 MiB)\nRunning simulation (2nd time) takes:\n  0.373982 seconds (138.59 k allocations: 160.657 MiB, 7.20% gc time)","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"Creating and simulating this small model (with only 450 cells) for the first time will take about 30 secs. And all subsequent runs will take less than 0.5 secs. In a long running Julia session (e.g., in Juno or Jupyter notebook), the slow start up time is often times acceptable. However, there are cases where this long start up become unacceptable. For such cases, it is recommended to use the PackageCompiler.jl package to speed up the start up time.","category":"page"},{"location":"precompile/#How-to-precompile","page":"Precompile","title":"How to precompile","text":"","category":"section"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"To precompile ResSimAD.jl, first install the PackageCompiler.jl package. Then run:","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"using ResSimAD\n\nfn = joinpath(pkgdir(ResSimAD), \"precompile\", \"precompile.jl\");\n\ninclude(fn)\n","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"This will take several minutes. You will see the following outputs:","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"Precompiling ResSimAD.jl.\nDefault system image will be replaced.\n[ Info: PackageCompiler: creating system image object file, this might take a while...\n[ Info: PackageCompiler: default sysimg replaced, restart Julia for the new sysimg to be in effect\n","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"After the precompiling finishes, restart Julia and run the following code again","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"println(\"Importing ResSimAD (1st time) takes:\")\n@time using ResSimAD\n\nprintln(\"Creating Sim object (1st time) takes:\")\n@time sim, options = get_model(\"example1\")\n\nprintln(\"Running simulation (1st time) takes:\")\n\n@time runsim(sim);\n\n\nprintln(\"\\nImporting ResSimAD (2nd time) takes:\")\n@time using ResSimAD\n\nprintln(\"Creating Sim object (2nd time) takes:\")\n@time sim, options = get_model(\"example1\")\n\nprintln(\"Running simulation (2nd time) takes:\")\n\n@time runsim(sim);\n","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"This time, importing ResSimAD.jl, creating Sim object and running simulation for the first time becomes almost as fast as the second calls:","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"Importing ResSimAD (1st time) takes:\n  0.001425 seconds (1.16 k allocations: 58.562 KiB)\nCreating Sim object (1st time) takes:\n  0.028607 seconds (63.63 k allocations: 4.854 MiB)\nRunning simulation (1st time) takes:\n  0.399527 seconds (193.98 k allocations: 163.970 MiB, 4.50% gc time)\n\nImporting ResSimAD (2nd time) takes:\n  0.000831 seconds (751 allocations: 39.719 KiB)\nCreating Sim object (2nd time) takes:\n  0.002119 seconds (3.04 k allocations: 1.227 MiB)\nRunning simulation (2nd time) takes:\n  0.352242 seconds (138.59 k allocations: 160.657 MiB, 4.27% gc time)\n","category":"page"},{"location":"precompile/#What-precompiling-does","page":"Precompile","title":"What precompiling does","text":"","category":"section"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"The PackageCompiler first runs a precompile execution file (precompile/precompule_execution_file.jl). This file executes the most commonly used ResSimAD.jl API functions. All functions and subroutines that were executed get compiled and stored. These compiled functions are combined with the default Julia system image to form a new system image. The new system image replaces the default Julia system image.","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"Future Julia sessions will launch with this new system image. The compiled functions will be loaded automatically. As a result, importing ResSimAD.jl, creating Sim object and running simulation for the first time become much faster.","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"This also means the ResSimAD.jl is locked to the version that gets compiled. Therefore, any modification to the ResSimAD.jl package (if you are developing ResSimAD.jl) or any version update will be shadowed. To solve this problem, there are three options","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"Re-precompile ResSimAD.jl.\nIn stead of replacing the default system image with the new system image, we can keep both system images:","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"using ResSimAD\n\nreplace_default = 0\n\nfn = joinpath(pkgdir(ResSimAD), \"precompile\", \"precompile.jl\");\n\ninclude(fn)\n","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"This will create a new system image called ResSimADSysImg.so. Then we can launch Julia with this new system image to speed up ResSimAD.jl:","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"julia -J ResSimADSysImg.so","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"or launch Julia with the default system image as usual (for example when developing ResSimAD.jl where you are constantly modifying ResSimAD.jl or when you are using Julia for other tasks).","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"julia","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"We can also specify the path for the new system image:","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"using ResSimAD\n\nreplace_default = 0\n\nsysimage_path = \"mypath/mysysimg.so\"\n\nfn = joinpath(pkgdir(ResSimAD), \"precompile\", \"precompile.jl\");\n\ninclude(fn)\n\n","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"Restore default system image: if the default system image is replaced, we can restore it with","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"using PackageCompiler\nrestore_default_sysimage()","category":"page"},{"location":"precompile/","page":"Precompile","title":"Precompile","text":"This will restore the default system image. The new system image that contains precompiled ResSimAD.jl related functions will be discarded .","category":"page"},{"location":"python/#Python-usage","page":"Python usage","title":"Python usage","text":"","category":"section"},{"location":"python/","page":"Python usage","title":"Python usage","text":"With the PyJulia python package, ResSimAD.jl is also accessible from Python.","category":"page"},{"location":"python/#PyJulia-setup","page":"Python usage","title":"PyJulia setup","text":"","category":"section"},{"location":"python/","page":"Python usage","title":"Python usage","text":"Install the PyJulia package in python and setup the link between Julia and Python, following the steps described in PyJulia. And make sure that ResSimAD.jl is runnable in the Julia version that is linked to Python.","category":"page"},{"location":"python/#Basic-workflow-in-Python","page":"Python usage","title":"Basic workflow in Python","text":"","category":"section"},{"location":"python/","page":"Python usage","title":"Python usage","text":"After installing PyJulia, calling import julia in Python will launch a Julia process in the background. With from julia import Main, we can access variable x in the background Julia process at Main.x.","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"We can then import the ResSimAD module with from julia import ResSimAD.","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"import julia\nfrom julia import Main\nfrom julia import ResSimAD","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"Simulation setups can be specified using a Python dictionary.","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"options = {}\n# Grid and Rock\noptions[\"nx\"] = 30; options[\"ny\"] = 15; options[\"nz\"] = 1;\noptions[\"dx\"] = 50.; options[\"dy\"] = 50.; options[\"dz\"] = 20.;\noptions[\"d\"] = 3000.\noptions[\"perm\"] = 200.; options[\"poro\"] = 0.2;\n\n# Fluid\noptions[\"fluid\"] = \"OW\"\noptions[\"po\"] = 6000.; options[\"sw\"] = 0.1;\noptions[\"PVDO\"] = ResSimAD.get_example_data(\"PVDO.DAT\");\noptions[\"PVTW\"] = ResSimAD.get_example_data(\"PVTW.DAT\");\noptions[\"SWOF\"] = ResSimAD.get_example_data(\"SWOF.DAT\");\n\n# Wells\noptions[\"producers\"] = [];\np1 = {};\np1[\"name\"] = \"P1\"; p1[\"perforation\"] = [(1,1,1)]; p1[\"radius\"] = 0.5;\np1[\"mode\"] = \"bhp\"; p1[\"target\"] = 5500.;\noptions[\"producers\"].append(p1);\n\noptions[\"injectors\"] = [];\ni1 = {};\ni1[\"name\"] = \"I1\"; i1[\"perforation\"] = [(30,15,1)]; i1[\"radius\"] = 0.5;\ni1[\"mode\"] = \"bhp\"; i1[\"target\"] = 7000.;\noptions[\"injectors\"].append(i1);\n\n# Schedule\noptions[\"dt0\"] = 0.1;\noptions[\"dt_max\"] = 50.;\noptions[\"t_end\"] = 1825.0;\noptions[\"min_err\"] = 1.0e-3","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"Then we can pass the options to the ResSimAD.Sim function to create a Sim object in the background Julia process. This Sim object is accessible with Main.sim.","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"Main.sim = ResSimAD.Sim(options)","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"To run simulation, simply call","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"ResSimAD.runsim(Main.sim)","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"To extract simulation results, run the following code. The returned simulation will be converted to numpy arrays. We can then analyze/visualize the results in Python with matplotlib (not shown here).","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"t = ResSimAD.get_well_rates(Main.sim, \"P1\", \"TIME\")\nqo = ResSimAD.get_well_rates(Main.sim, \"P1\", \"ORAT\")\nqw = ResSimAD.get_well_rates(Main.sim, \"P1\", \"WRAT\")\npo = ResSimAD.get_state_map(Main.sim, \"po\", t[-1])\nsw = ResSimAD.get_state_map(Main.sim, \"sw\", t[-1])","category":"page"},{"location":"python/#Advanced-workflow-in-Python","page":"Python usage","title":"Advanced workflow in Python","text":"","category":"section"},{"location":"python/#Dynamic-simulation-control-in-Python","page":"Python usage","title":"Dynamic simulation control in Python","text":"","category":"section"},{"location":"python/","page":"Python usage","title":"Python usage","text":"Dynamic simulation control is also doable in Python.","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"import numpy as np\n# Create the example1 model\nMain.sim, Main.options = ResSimAD.get_model(\"example1\")\n# Change well target every 100 days\ntsteps = [100., 200., 300.];\nfor t in tsteps:\n    p1_bhp = np.random.rand()*400. + 5500.;\n    i1_bhp = np.random.rand()*400. + 6100.;\n    ResSimAD.change_well_target(Main.sim, \"P1\", p1_bhp)\n    ResSimAD.change_well_target(Main.sim, \"I1\", i1_bhp)\n    ResSimAD.change_dt(Main.sim, 5.0)\n    ResSimAD.step_to(Main.sim, t)\n    print(Main.sim.scheduler.t_current)\n\n# Change well target every 5 timesteps\nfor i in range(2):\n    p1_bhp = np.random.rand()*400. + 5500.;\n    i1_bhp = np.random.rand()*400. + 6100.;\n    ResSimAD.change_well_target(Main.sim, \"P1\", p1_bhp)\n    ResSimAD.change_well_target(Main.sim, \"I1\", i1_bhp)\n    ResSimAD.change_dt(Main.sim, 5.0)\n    for j in range(5):\n        ResSimAD.time_step(Main.sim)\n    print(Main.sim.scheduler.t_current)\n\n# Add new well\ni2 = {\n    \"name\": \"I2\",\n    \"perforation\": [(8,12,1)],\n    \"radius\": 0.5,\n    \"mode\": \"bhp\",\n    \"target\": 6500.\n}\n\nResSimAD.add_well(Main.sim, \"injector\", i2)\n\nt_end = 1200.\nResSimAD.step_to(Main.sim, t_end)\nprint(Main.sim.scheduler.t_current)\n","category":"page"},{"location":"python/#Run-multiple-simulations-in-parallel-in-Python","page":"Python usage","title":"Run multiple simulations in parallel in Python","text":"","category":"section"},{"location":"python/","page":"Python usage","title":"Python usage","text":"The example in Run multiple simulations in parallel shows how to run multiple simulations in parallel in Julia. The following example shows how to run multiple simulations in Python.","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"import julia\nfrom julia import Main","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"We can use the Distributed Julia module in Python to launch multiple Julia worker processes","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"from julia import Distributed\nMain.nrun = 5\nDistributed.addprocs(Main.nrun)","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"Next we need use the @everywhere, @spawnat macro in Julia. This is a Julia specific syntax, which can not be directly called in Python. But we can use the Main.eval method to execute any Julia code in the background Julia process:","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"Main.eval(\n\"\"\"\nusing Distributed\n\n@everywhere using ResSimAD\n\n@everywhere function forecast(perm)\n    _, options = get_model(\"example1\")\n    options[\"perm\"] = perm\n    sim = Sim(options);\n    runsim(sim);\n    t = get_well_rates(sim, \"P1\", \"TIME\")\n    qo = get_well_rates(sim, \"P1\", \"ORAT\")\n    qw = get_well_rates(sim, \"P1\", \"WRAT\")\n    return t, qo, qw\nend\n\n\"\"\"\n)","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"We can still create variables in Python and pass to Julia:","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"import numpy as np\nMain.perms = np.random.rand(Main.nrun) * 100 + 200","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"Next we launch multiple simulations:","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"Main.eval(\"\"\"\ndata_ref = []\nfor (i, worker) in enumerate(workers())\n    push!(data_ref, @spawnat worker forecast(perms[i]))\nend\n\"\"\")\n","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"Notice that the perms variable in the above Julia code was created in Python and passed to Julia.","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"Then we run the following code to fetch simulation results from the Julia worker processes to the Julia main process.","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"Main.eval(\"\"\"\nresults = []\nfor i = 1:nrun\n    push!(results, fetch(data_ref[i]))\nend\n\"\"\")","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"The results from the multiple simulations are then accessible in the Main.results variable in Python. In this case, the Main.results is a list of 5 tuples, each tuple contains three numpy arrays - (t, qo, qw)","category":"page"},{"location":"python/#Use-precompiled-ResSimAD.jl-in-Python","page":"Python usage","title":"Use precompiled ResSimAD.jl in Python","text":"","category":"section"},{"location":"python/","page":"Python usage","title":"Python usage","text":"We can also use precompiled ResSimAD.jl in Python.","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"The first appraoch is to precompile ResSimAD.jl and replace the default Julia system image, as described in Precompile.","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"Alternatively, in PyJulia, we can use a customize system image for Julia, as described in the Custom Julia system image section of the PyJulia documentation. If we have precompiled ResSimAD.jl and created a custom system image called ResSimADSysImg.so. Then we call uses this system image to initialize Julia in Python:","category":"page"},{"location":"python/","page":"Python usage","title":"Python usage","text":"from julia import Julia\njl = Julia(sysimage=\"ResSimADSysImg.so\")\n\nfrom julia import Main\nfrom julia import ResSimAD","category":"page"},{"location":"benchmark/#Benchmark","page":"Benchmark","title":"Benchmark","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"In this section, ResSimAD.jl is compared with Eclipse, ADGPRS, MRST and OPM.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Input files, scripts, results and output logs for all simulators are available in ResSimAD.jl/benchmark/. To reproduce the benchmarking results, proper installation, environmental variables setup and valid licenses for Eclipse, ADGPRS, MRST and OPM are required.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The version, machine and CPU information for producing the benchmarking results presented here is summarized in the table below.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Simulator Version Machine CPU\nResSimAD.jl dev Windows 10 (x86_64-w64-mingw32) Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz\nEclipse v2017.2 Windows 10 (x86_64-w64-mingw32) Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz\nMRST 2020a Windows 10 (x86_64-w64-mingw32) Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz\nADGPRS 1.9 Ubuntu-20.04 on WSL2 (x86_64-pc-linux-gnu) Intel(R) Core(TM) i9-9920X CPU @ 3.50GHz\nOPM 2020.04 Ubuntu-20.04 on WSL2 (x86_64-pc-linux-gnu) Intel(R) Core(TM) i9-9920X CPU @ 3.50GHz","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Note that at the time these benchmarking results were generated, we ended up using two different machines, due to practical reasons such as different supported platforms from different simulators, availability of licenses (Eclipse and matlab license for MRST). Therefore, the performances of the simulators are subject to small differences. These differences are in general small and will not affect the conclusions presented in this benchmarking study.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"We thank the Stanford Energy Resources Engineering department and the Stanford Smart Fields Consortium for providing ADGPRS, license for Eclipse and license for Matlab.","category":"page"},{"location":"benchmark/#Example1","page":"Benchmark","title":"Example1","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The ResSimAD.Models.example1 model is a 2D deal-oil model (30x15 grid) with one injector and one producer. This simple model is a good candidate for testing the overhead, especially those introduced by AD (except for Eclipse, all other simulators use AD).","category":"page"},{"location":"benchmark/#Simulation-results-comparison","page":"Benchmark","title":"Simulation results comparison","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Simulation results for example1 from all simulators are stored in ResSimAD.jl/benchmark/example1. The following code reads and plots these stored simulation results.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"using ResSimAD\nusing Plots\nusing Plots.PlotMeasures\ngr(format=:svg) # hide\nENV[\"GKSwstype\"] = \"100\" #hide\n# Load results\ninclude(joinpath(pkgdir(ResSimAD), \"benchmark\", \"example1\", \"load_results.jl\"))\n\n# Plot production rates\nlinetypes = Dict([\n    (\"ResSimAD\", :path),\n    (\"MRST\", :scatter),\n    (\"Eclipse\", :scatter),\n    (\"ADGPRS\", :scatter),\n    (\"OPM\", :scatter),\n])\n\nmarkers = Dict([\n    (\"ResSimAD\", :hline),\n    (\"MRST\", :diamond),\n    (\"Eclipse\", :circle),\n    (\"ADGPRS\", :hexagon),\n    (\"OPM\", :star4),\n])\n\nplts = []\nto_plot = [\"P1 oil rate\", \"P1 water rate\", \"I1 water inj. rate\"]\nfor key in to_plot\n    p = plot(xlabel=\"Day\", ylabel=key * \" (stb/day)\", size=(420, 320),\n             legend=:right, title=key)\n    for case in sort(collect(keys(results)))\n        plot!(p, results[case][\"Day\"][7:3:end], abs.(results[case][key][7:3:end]), label=case,\n                line=(linetypes[case], 3.0), marker=markers[case])\n    end\n    push!(plts, p)\nend\n\nplot(plts..., layout=(3,1), size=(320,820), left_margin=20px)","category":"page"},{"location":"benchmark/#Performance-comparison","page":"Benchmark","title":"Performance comparison","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Each simulator was ran for 5 times. The average run times are plotted below. Run times for ResSimAD.jl were directly measured. Run times for other simulators were parsed from the output logs. This way, the overhead of launching the simulators was not included, especially for MRST where launching Matlab took quite some time. For all simulators, the default linear solver was used. File IO for Eclipse, OPM and ADGPRS was minimized as much as possible.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Simulator Linear Solver Time steps Newton Iterations\nResSimAD.jl GMRES + ILU 70 186\nEclipse ORTHOMIN + NF 77 178\nMRST Matlab Backslash 70 176\nADGPRS GMRES + CPR0 72 197\nOPM BiCG-stab + ILU0 68 221","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"# Plot average run time\np1 = plot(ylabel=\"Average run time (seconds)\", legend=false);\nfor key in sort!(collect(keys(runtimes)))\n    bar!(p1, [key], [mean(runtimes[key])], color=:gray)\nend\n\np2 = plot(ylabel=\"Average run time (seconds)\", legend=false);\nfor key in sort!([\"Eclipse\", \"ResSimAD\", \"ADGPRS\", \"OPM\"])\n    bar!(p2, [key], [mean(runtimes[key])], color=:gray)\nend\n\nplot(p1, p2, layout=(1,2), size=(720, 280), bottom_margin = 10px)","category":"page"},{"location":"benchmark/#Example-2","page":"Benchmark","title":"Example 2","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The ResSimAD.Models.example2 model is a 2D deal-oil model (60x60 grid) with two injectors and two producers. The log-permeability field represents a bimodal channelized system. This is a typical research simluation model.","category":"page"},{"location":"benchmark/#Simulation-results-comparison-2","page":"Benchmark","title":"Simulation results comparison","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Simulation results for example2 from all simulators are stored in ResSimAD.jl/benchmark/example2. The following code reads and plots these stored simulation results.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"# Load results\ninclude(joinpath(pkgdir(ResSimAD), \"benchmark\", \"example2\", \"load_results.jl\"))\n\nplts = []\nto_plot = [\"P1 oil rate\", \"P1 water rate\",\n            \"P2 oil rate\", \"P2 water rate\",\n            \"I1 water inj. rate\", \"I2 water inj. rate\"]\nfor key in to_plot\n    p = plot(xlabel=\"Day\", ylabel=key * \" (stb/day)\", size=(420, 320),\n             legend=:right, title=key)\n    for case in sort(collect(keys(results)))\n        plot!(p, results[case][\"Day\"][7:3:end], abs.(results[case][key][7:3:end]), label=case,\n                line=(linetypes[case], 3.0), marker=markers[case])\n    end\n    push!(plts, p)\nend\n\nplot(plts..., layout=(3,2), size=(640,820), left_margin=20px, bottom_margin=10px)","category":"page"},{"location":"benchmark/#Performance-comparison-2","page":"Benchmark","title":"Performance comparison","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Performance from all simulators for example2 are summarized below.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Simulator Linear Solver Time steps Newton Iterations\nResSimAD.jl GMRES + ILU 41 119\nEclipse ORTHOMIN + NF 46 107\nMRST Matlab Backslash 41 123\nADGPRS GMRES + CPR0 41 112\nOPM BiCG-stab + ILU0 45 210 (42 failed)","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"# Plot average run time\np1 = plot(ylabel=\"Average run time (seconds)\", legend=false);\nfor key in sort!(collect(keys(runtimes)))\n    bar!(p1, [key], [mean(runtimes[key])], color=:gray)\nend\n\np2 = plot(ylabel=\"Average run time (seconds)\", legend=false);\nfor key in sort!([\"Eclipse\", \"ResSimAD\", \"ADGPRS\", \"OPM\"])\n    bar!(p2, [key], [mean(runtimes[key])], color=:gray)\nend\n\nplot(p1, p2, layout=(1,2), size=(720, 280), bottom_margin = 10px)","category":"page"},{"location":"benchmark/#Example-4","page":"Benchmark","title":"Example 4","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"The ResSimAD.Models.example4 model is a 3D deal-oil model (60x60x40 grid) with two injectors and two producers. ","category":"page"},{"location":"benchmark/#Simulation-results-comparison-3","page":"Benchmark","title":"Simulation results comparison","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Simulation results for example4 from all simulators are stored in ResSimAD.jl/benchmark/example4. The following code reads and plots these stored simulation results.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"# Load results\ninclude(joinpath(pkgdir(ResSimAD), \"benchmark\", \"example4\", \"load_results.jl\"))\n\nplts = []\nto_plot = [\"P1 oil rate\", \"P1 water rate\",\n            \"P2 oil rate\", \"P2 water rate\",\n            \"I1 water inj. rate\", \"I2 water inj. rate\"]\n\nfor key in to_plot\n    p = plot(xlabel=\"Day\", ylabel=key * \" (stb/day)\", size=(420, 320),\n            legend=:left, title=key)\n    for case in sort(collect(keys(results)))\n    # for case in [\"Eclipse\", \"ResSimAD\", \"ADGPRS\", \"OPM\"]\n        plot!(p, results[case][\"Day\"][3:2:end], abs.(results[case][key][3:2:end]), label=case,\n                line=(linetypes[case], 3.0), marker=markers[case])\n    end\n    push!(plts, p)\nend\n\nplot(plts..., layout=(3,2), size=(640,820), left_margin=20px, bottom_margin=10px)","category":"page"},{"location":"benchmark/#Performance-comparison-3","page":"Benchmark","title":"Performance comparison","text":"","category":"section"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Each simulator was ran for 3 times. Performance from all simulators for example2 are summarized below.","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"Simulator Linear Solver Time steps Newton Iterations\nResSimAD.jl GMRES + CPR 65 252\nEclipse ORTHOMIN + NF 86 217\nADGPRS GMRES + CPR0 63 239\nOPM BiCG-stab + ILU0 59 231","category":"page"},{"location":"benchmark/","page":"Benchmark","title":"Benchmark","text":"# Plot average run time\np1 = plot(ylabel=\"Average run time (minutes)\", legend=false);\nfor key in sort!(collect(keys(runtimes)))\n    bar!(p1, [key], [mean(runtimes[key]) / 60.], color=:gray)\nend\n\nplot(p1, size=(360, 280), bottom_margin = 10px)","category":"page"},{"location":"#ResSimAD.jl","page":"Home","title":"ResSimAD.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"A light-weighted reservoir simulator in a modern programming language.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ResSimAD.jl is being tested internally. You will need to get access to the repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ResSimAD.jl is unregistered for now. In addition, the dependent JLL package libduneistlsolver_jll.jl and the solver package DuneIstlSolvers.jl are also unregistered.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Therefore, to install, we need to first manually install libduneistlsolver_jll.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add https://github.com/DeanLym/libduneistlsolver_jll.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next, we need to manually install DuneIstlSolvers.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add https://github.com/DeanLym/DuneIstlSolvers.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we can install ResSimAD.jl with","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add https://github.com/DeanLym/ResSimAD.jl.git","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Interactivity: run simulations in interactive programming environments such as Jupyter notebook and VSCode. With the PyJulia python module, ResSimAD.jl is also accessible from Python.\nDynamic control: run simulation timestep by timestep, or newton step by newton step, and modify parameters or controls dynamically.\nDistributed computing: with the Distributed Julia built-in module, it is very convenient to run multiple simulations in parallel. In addition, with the ClusterManagers.jl package, it is very convenient to run multiple simulations in parallel on a HPC cluster. This is very useful for tasks such as field optimization and history matching that require simulating a large number of models.","category":"page"},{"location":"#Automatic-Differentiation-(AD)","page":"Home","title":"Automatic Differentiation (AD)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An operator-overloading-based forward mode AD framework is developed to compute gradients automatically. Instead of using existing Julia AD packages such as Zygote.jl, Tracker.jl or DualNumbers.jl, a customized AD framework is developed here for the sake of efficiency. The AD framework underlying ResSimAD.jl is tailored for the operations in reservoir simulation. This allows maximum level of optimization which makes this AD framework almost as fast as hand-written differentiation. On the other hand, the AD framework may need to be extended if some new operations are introduced when extending the functionality of ResSimAD.jl.","category":"page"},{"location":"#Functionality","page":"Home","title":"Functionality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Functionality-wise, ResSimAD.jl is still at a very early stage. It currently works for simple simulation models:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Grid: 3D Cartesian grid\nFluid: two phase (oil-water) dead oil\nWell: single perforation","category":"page"},{"location":"","page":"Home","title":"Home","text":"But the underlying framework of ResSimAD.jl is designed for easy extension to more complex simulation models, such as those with unstructured grid, three-phase black oil fluid model, wells with multiple perforations. This is largely facilitated by the powerful type system and multiple dispatch in Julia, and the AD framework.","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the supported cases, the speed of ResSimAD.jl is comparable to professional simulators written in low-level languages including Eclipse, OPM and ADGPRS. See Benchmark for benchmark comparisons with MRST, ADGPRS, Eclipse and OPM.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"workflow.md\", \"workflow2.md\", \"precompile.md\", \"python.md\", \"input.md\", \"examples.md\", \"api.md\"]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"workflow2/#Advanced-workflow","page":"Advanced workflow","title":"Advanced workflow","text":"","category":"section"},{"location":"workflow2/#Dynamic-simulation-control","page":"Advanced workflow","title":"Dynamic simulation control","text":"","category":"section"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"ResSimAD.jl allows flexible control over simulation runs.","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"API functions ResSimAD.time_step and ResSimAD.step_to enable simulating the model for a single timestep, or to a specific time, respectively.","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"API functions ResSimAD.change_well_mode, ResSimAD.change_well_target, ResSimAD.shut_well and ResSimAD.add_well enable dynamic modification of well setups during a simulation run.","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"After changing well settings, time step size will be cut down to sim.scheduler.dt0. We can also use ResSimAD.change_dt to change the time step size.","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"Here is an example where well control settings are changed dynamically during simulation runs. This is very convenient in the context of well control optimizations.","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"# Create simulation model\nusing ResSimAD: get_model, change_well_target, change_dt, step_to, time_step\n\nsim, options = get_model(\"example1\");\n\n# Change BHP control every 100 days\ntsteps = [100., 200., 300.];\nfor t in tsteps\n    p1_bhp = rand()*400. + 5500.;\n    i1_bhp = rand()*400. + 6100.;\n    change_well_target(sim, \"P1\", p1_bhp)\n    change_well_target(sim, \"I1\", i1_bhp)\n    change_dt(sim, 5.0)\n    step_to(sim, t)\nend\n\n# Change BHP every 5 time steps\nfor i = 1:2\n    p1_bhp = rand()*400. + 5500.;\n    i1_bhp = rand()*400. + 6100.;\n    change_well_target(sim, \"P1\", p1_bhp)\n    change_well_target(sim, \"I1\", i1_bhp)\n    change_dt(sim, 5.0)\n    for j = 1:5\n        time_step(sim)\n    end\nend\n","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"## Plot results\nusing ResSimAD: get_well_rates, get_state_map, get_grid_index, isproducer\nusing Plots\nusing Plots.PlotMeasures\ncmap = cgrad(:jet);\ngr(format=:svg) # hide\nENV[\"GKSwstype\"] = \"100\" #hide\n\n# BHP\nt = get_well_rates(sim, \"P1\", \"TIME\");\n\npw_p1 = get_well_rates(sim, \"P1\", \"WBHP\");\npw_i1 = get_well_rates(sim, \"I1\", \"WBHP\");\np1 = plot(t, pw_p1, color=:black, marker=true,\n     xlabel=\"Day\", ylabel=\"BHP (psi)\",\n     title=\"P1 BHP\");\np2 = plot(t, pw_i1, color=:black, marker=true,\n     xlabel=\"Day\", ylabel=\"BHP (psi)\",\n     title=\"I1 BHP\");\nplot(p1, p2, layout=(1,2), legend=false, size=(720,280), bottom_margin = 10px)","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"# Oil rate and water injection rate\nqo = get_well_rates(sim, \"P1\", \"ORAT\");\nqw = get_well_rates(sim, \"I1\", \"WRAT\");\np1 = plot(t, qo, color=:black, marker=true,\n     xlabel=\"Day\", ylabel=\"Oil rate (STB/Day)\",\n     title=\"P1 oil rate\");\np2 = plot(t, -qw, color=:black, marker=true,\n     xlabel=\"Day\", ylabel=\"Water inj. rate (STB/Day)\",\n     title=\"I1 water injection rate\");\nplot(p1, p2, layout=(1,2), legend=false, size=(720,280), bottom_margin = 10px)","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"# Define a function for plotting wells\nfunction plot_wells_2d(plt, sim; markersize=5, color=:white)\n    for w in values(sim.facility)\n        i, j, _ = get_grid_index(sim.reservoir.grid, w.ind[1])\n        if isproducer(w)\n            marker = :circle\n        else\n            marker = :dtriangle\n        end\n        scatter!(plt, [j,], [i,], m=(marker, markersize, color), legend=false)\n    end\nend\n\n# Plot state maps\npo = get_state_map(sim, \"po\", t[end]);\nsw = get_state_map(sim, \"sw\", t[end]);\np1 = heatmap(reshape(po, sim.nx, sim.ny), color=cmap, title=\"Po at day $(t[end])\");\nplot_wells_2d(p1, sim);\np2 = heatmap(reshape(sw, sim.nx, sim.ny), color=cmap, title=\"Sw at day $(t[end])\");\nplot_wells_2d(p2, sim);\nplot(p1, p2, layout=(1,2), size=(700,450))","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"We can also add new well dynamically. This can be useful for field development optimization.","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"using ResSimAD: add_well\n\nnew_well = Dict([\n    (\"name\", \"I2\"),\n    (\"perforation\", [(8,12,1)]),\n    (\"radius\", 0.5),\n    (\"mode\", \"bhp\"),\n    (\"target\", 6500.)\n])\n\nadd_well(sim, \"injector\", new_well);\n\nt_end = 1200.;\nstep_to(sim, t_end);\n","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"# Plot production curves\nqo = get_well_rates(sim, \"P1\", \"ORAT\");\nt2 = get_well_rates(sim, \"I2\", \"TIME\");\nqw1 = get_well_rates(sim, \"I1\", \"WRAT\");\nqw2 = get_well_rates(sim, \"I2\", \"WRAT\");\np1 = plot(t, qo, color=:black, marker=true, label = \"P1\",\n     xlabel=\"Day\", ylabel=\"Oil rate (STB/Day)\",\n     title=\"P1 oil rate\");\np2 = plot(t, -qw1, color=:blue, marker=true, label=\"I1\");\nplot!(p2, t2, -qw2, color=:red, marker=true, label=\"I2\",\n     xlabel=\"Day\", ylabel=\"Water inj. rate (STB/Day)\",\n     title=\"Water injection rate\");\nplot(p1, p2, layout=(1,2), size=(720,280), bottom_margin = 10px)","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"# Plot state maps\npo = get_state_map(sim, \"po\", t_end);\nsw = get_state_map(sim, \"sw\", t_end);\np1 = heatmap(reshape(po, sim.nx, sim.ny), color=cmap, title=\"Po at day $(t[end])\");\nplot_wells_2d(p1, sim);\np2 = heatmap(reshape(sw, sim.nx, sim.ny), color=cmap, title=\"Sw at day $(t[end])\");\nplot_wells_2d(p2, sim);\nplot(p1, p2, layout=(1,2), size=(700,450))","category":"page"},{"location":"workflow2/#Run-multiple-simulations-in-parallel","page":"Advanced workflow","title":"Run multiple simulations in parallel","text":"","category":"section"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"With the Julia Distributed module, it is very convenient to run multiple simulations in parallel. Here we provide an example:","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"First, launch Julia worker processes.","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"using Distributed: addprocs, @everywhere, @spawnat, fetch, workers, rmprocs\n\n# Launch 5 Julia worker processes\nnrun = 5\naddprocs(nrun);\n","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"Then import ResSimAD.jl and define a forecast function on all worker processes with the @everywhere macro.","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"@everywhere using ResSimAD: get_model, Sim, runsim, get_well_rates\n\n@everywhere function forecast(perm)\n    _, options = get_model(\"example1\")\n    options[\"perm\"] = perm\n    sim = Sim(options);\n    runsim(sim);\n    t = get_well_rates(sim, \"P1\", \"TIME\")\n    qo = get_well_rates(sim, \"P1\", \"ORAT\")\n    qw = get_well_rates(sim, \"P1\", \"WRAT\")\n    return t, qo, qw\nend\n","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"Next, launch simulations on the worker processes with the @spawnat macro.","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"perms = rand(nrun) * 200.0 .+ 100.0;\n\ndata_ref = []\nfor (i, worker) in enumerate(workers())\n    push!(data_ref, @spawnat worker forecast(perms[i]))\nend\n","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"Next, retrieve simulation results with the fetch function","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"results = []\nfor i = 1:nrun\n    push!(results, fetch(data_ref[i]))\nend","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"We can then plot simulation results","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"nrun = 5; # hide\nperms = rand(nrun) * 200.0 .+ 100.0; # hide\nusing ResSimAD # hide\nResSimAD.silence() # hide\nfunction forecast(perm) # hide\n    _, options = get_model(\"example1\") # hide\n    options[\"perm\"] = perm # hide\n    sim = Sim(options); # hide\n    runsim(sim); # hide\n    t = get_well_rates(sim, \"P1\", \"TIME\") # hide\n    qo = get_well_rates(sim, \"P1\", \"ORAT\") # hide\n    qw = get_well_rates(sim, \"P1\", \"WRAT\") # hide\n    return t, qo, qw # hide\nend # hide\nresults = [] # hide\nfor i = 1:nrun push!(results, forecast(perms[i])) end # hide\nusing Plots\nusing Plots.PlotMeasures\ncmap = cgrad(:jet);\n\np1 = plot(xlabel=\"Day\", ylabel=\"Oil rate (STB/Day)\", title=\"P1 oil rate\");\np2 = plot(xlabel=\"Day\", ylabel=\"Water rate (STB/Day)\", title=\"P1 water rate\");\nfor i = 1:nrun\n    t, qo, qw = results[i]\n    plot!(p1, t, qo, label=\"run $i\", linewidth=2, marker=true)\n    plot!(p2, t, qw, label=\"run $i\", linewidth=2, marker=true)\nend\nplot(p1, p2, layout=(1,2), size=(720, 280), bottom_margin = 10px)","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"The worker Julia processes will be automatically terminated if the main Julia process terminates. Alternative, we can terminate the worker Julia processes manually:","category":"page"},{"location":"workflow2/","page":"Advanced workflow","title":"Advanced workflow","text":"for worker in workers()\n    rmprocs(worker)\nend","category":"page"}]
}
